include common.make

SHELL=/bin/bash

DOCKER_CONTAINERS:=$(shell find . -iname Dockerfile -type f | awk -F '/' '{print $$2}')

DOCKER_COMPOSE_EXTRAS:=${DOCKER_COMPOSE_EXTRAS}

AUTOGENERATED_COMPOSE_FILES:=

PRIMARY_COMPOSE_FILE:=docker-compose.yml
PLATFORM_DOCKER_COMPOSE=$(DOCKER_COMPOSE_ENV) $(DOCKER_COMPOSE) -p $(DOCKER_COMPOSE_PROJECT_NAME) -f $(PRIMARY_COMPOSE_FILE) -f $(COMPOSE_PLATFORM_FILE) $(foreach f,$(AUTOGENERATED_COMPOSE_FILES), -f $(f)) $(DOCKER_COMPOSE_EXTRAS)
COMPOSE_ENVIRONMENT_FILES=$(foreach c,$(DOCKER_CONTAINERS),$(c)/compose.env)
SETUP_FILES:=$(foreach c,$(DOCKER_CONTAINERS),$(c)/setup)
COMPOSE_ARGUMENTS_FILES:=$(shell find . -iname ".args")
SOURCE_BUILD_ARGS=$(shell if [ -z "$(COMPOSE_ARGUMENTS_FILES)" ]; then echo true; else echo source $(COMPOSE_ARGUMENTS_FILES); fi)

CONTAINER_DEBUG_TARGETS:=$(foreach c,$(DOCKER_CONTAINERS),debug/$(c))

INSTALLED_CRON_PATH:=$(CRON_BASE_PATH)/$(DOCKER_COMPOSE_PROJECT_NAME)

INSTALLED_CRON_STDOUT_LOG:=$(LOGS_DIRECTORY)/startup.stdout.log
INSTALLED_CRON_STDERR_LOG:=$(LOGS_DIRECTORY)/startup.stderr.log

NGINX_REVERSE_PROXY_TEMPLATE_FILE:=nginx/reverse-proxy.template.conf
NGINX_REVERSE_PROXY_FILE:=nginx/reverse-proxy.conf

PIHOLE_LAN_LIST_FILE:=pi-hole/lan.list
PIHOLE_SEARCH_DOMAINS:=home local

PLEX_VOLUMES_COMPOSE_FILE:=plex/plex-volumes.yml
AUTOGENERATED_COMPOSE_FILES+=$(PLEX_VOLUMES_COMPOSE_FILE)

# List of environment variables in projects that shouldn't be treated as secret.
SAVE_ENV_VARS=\
	MYSQL_USER\
	MYSQL_DATABASE\
	FF_APP_ENV\
	RESILIO_SERVER_USERNAME\
	ADVERTISE_IP

# Docker Compose has some odd conditions that require all containers to be
#   properly configured, even if you're only trying to start one. Because of
#   that, this list will be set as a dependency of anything that starts any
#   containers just to make sure that the containers are built.
# Also ensure git hooks are appropriately set up, so that after any amount of
#   testing or playing around with the repo, hooks will be configured.
ANY_CONTAINER_BUILD_DEPS:=\
	$(COMPOSE_ENVIRONMENT_FILES)\
	$(NGINX_REVERSE_PROXY_FILE)\
	$(PIHOLE_LAN_LIST_FILE)\
	$(PLEX_VOLUMES_COMPOSE_FILE)\
	base-image\
	volumes\
	.git/hooks/pre-push

.PHONY: all
all: setup $(COMPOSE_ENVIRONMENT_FILES) compose-up

.PHONY: setup
setup: $(SETUP_FILES)

$(SETUP_FILES):
	$(MAKE) -C $(@D) setup


# Base image is needed for several containers. Make sure that it's available
#   before any attempt at building other containers, or else docker will try to
#   pull an image called `ncfgbase`, and it won't find one.
.PHONY: base-image
base-image:
	$(DOCKER) build . -f BaseUpdatedUbuntuDockerfile -t ncfgbase

.PHONY: compose-up
compose-up: $(ANY_CONTAINER_BUILD_DEPS)
	$(SOURCE_BUILD_ARGS) && $(PLATFORM_DOCKER_COMPOSE) build
	$(SOURCE_BUILD_ARGS) && $(PLATFORM_DOCKER_COMPOSE) up -d

.PHONY: compose-down
compose-down:
	$(SOURCE_BUILD_ARGS) && $(PLATFORM_DOCKER_COMPOSE) down

# Build an individual container, rather than bringing the whole system up.
# Building any container requires that all environment files are present.
# For whatever reason, docker-compose reads in environments of services that
#   aren't in any way related to the service that's being started.
.PHONY: $(DOCKER_CONTAINERS)
$(DOCKER_CONTAINERS): $(ANY_CONTAINER_BUILD_DEPS)
	$(SOURCE_BUILD_ARGS) && $(PLATFORM_DOCKER_COMPOSE) build $@ $$(python .scripts/get_dependencies_from_compose_file.py $@ $(PRIMARY_COMPOSE_FILE))
	$(SOURCE_BUILD_ARGS) && $(PLATFORM_DOCKER_COMPOSE) up -d $@

# Debug phony target to start up a container using docker compose, but also to
#   set it up with std_in available, so even if it's a bash command the
#   container's running, it can still be attached to.
.INTERMEDIATE: $(CONTAINER_DEBUG_FILES)
.PHONY: $(CONTAINER_DEBUG_TARGETS)
$(CONTAINER_DEBUG_TARGETS):
	printf "version: '3'\nservices:\n  %s:\n    stdin_open: true\n" $$(basename $@) > "$$(basename $@)/debug.yml"
	DOCKER_COMPOSE_EXTRAS="-f $$(basename $@)/debug.yml" $(MAKE) $$(basename $@)
	rm -rf  "$$(basename $@)/debug.yml"


# Treat the compose files as phony, so the individual service Makefiles can
#   manage prerequisites.
.PHONY: $(COMPOSE_ENVIRONMENT_FILES)
$(COMPOSE_ENVIRONMENT_FILES):
	$(MAKE) -C $(@D) compose.env


# Helper to create all compose environment files.
.PHONY: env
env: $(COMPOSE_ENVIRONMENT_FILES)


# Helper to print out the full configuration that docker-compose will use to
#   bring up the whole system.
.PHONY: show-config
show-config: $(COMPOSE_ENVIRONMENT_FILES)
	$(SOURCE_BUILD_ARGS) && $(PLATFORM_DOCKER_COMPOSE) config


.PHONY: kill
kill: compose-down


.PHONY: install
install: $(INSTALLED_CRON_PATH)


$(INSTALLED_CRON_PATH):
	@mkdir -p $(LOGS_DIRECTORY)
	@echo '@reboot root bash $(CURDIR)/startup.sh > $(INSTALLED_CRON_STDOUT_LOG) 2> $(INSTALLED_CRON_STDERR_LOG)' > $(INSTALLED_CRON_PATH)


.PHONY: clean
clean:
	$(DOCKER) container prune -f
	$(DOCKER) image prune -f
	rm -rf $(COMPOSE_ENVIRONMENT_FILES)
	rm -rf $(SETUP_FILES)


.PHONY: backups
backups:
	@find . -maxdepth 2 -iname "backup.sh" -exec dirname {} \; | while read bak; do \
		make -C $${bak} backup; \
	done


# Helper to create a new skeleton application template.
.PHONY: app
app:
	@if [ -z "$${APP_NAME}" ]; then \
		echo >&2 "Failed to find environment '\$$APP_NAME'"; \
		exit -1; \
	fi

	mkdir -p $${APP_NAME}
	printf 'include ../docker.make\n' > $${APP_NAME}/Makefile
	printf 'FROM ncfgbase\n\nRUN apt-get update -y\n\nCMD ["/bin/bash"]\n' > $${APP_NAME}/Dockerfile


# Volumes need to be created before docker-compose will let any individual
#   service start, so if there are volumes defined in any of the compose files
#   create them before trying to start any containers
.PHONY: volumes
volumes:
	@python .scripts/get_volumes_from_compose_file.py '$(PRIMARY_COMPOSE_FILE)' | while read line; do \
		if [ ! -z "$$line" ]; then \
			$(DOCKER) volume create $$line; \
		fi \
	done
	@python .scripts/get_volumes_from_compose_file.py $(COMPOSE_PLATFORM_FILE) | while read line; do \
		if [ ! -z "$$line" ]; then \
			$(DOCKER) volume create $$line; \
		fi \
	done


$(NGINX_REVERSE_PROXY_FILE):
	@python .scripts/get_hostname_container_webserver_port.py '$(PRIMARY_COMPOSE_FILE)' | while read line; do \
		arr=($${line[@]}); \
		sed "s/"'$${HOSTNAME}'"/$${arr[0]}/g; s/"'$${HOSTPORT}'"/$${arr[1]}/g" $(NGINX_REVERSE_PROXY_TEMPLATE_FILE) >> $(NGINX_REVERSE_PROXY_FILE); \
	done


$(PIHOLE_LAN_LIST_FILE):
	$(foreach domain,$(PIHOLE_SEARCH_DOMAINS),\
		python .scripts/get_hostnames.py '$(PRIMARY_COMPOSE_FILE)' | while read line; do \
			arr=($${line[@]}); \
			hostname=$${arr[0]}; \
			printf '$${SERVER_IP}	%s.%s.	%s\n' $$hostname $(domain) $$hostname >> $(PIHOLE_LAN_LIST_FILE); \
		done; \
	)


$(PLEX_VOLUMES_COMPOSE_FILE):
	printf "version: '3'\nservices:\n  plex:\n    volumes:\n" > $(PLEX_VOLUMES_COMPOSE_FILE)
	awk '{print "      - "$$2":"$$1}' plex/volumes.txt >> $(PLEX_VOLUMES_COMPOSE_FILE)


.git/hooks/pre-push:
	# For whatever reason, this can choose to run despite the file already
	#   existing and having no dependencies. Possibly an issue with having a
	#   symlink as a target?
	ln -sf ${PWD}/.scripts/hooks/pre-push.sh $@


# Search though all .env files, and fail the command if any secret is found
#   anywhere in the git repo history. Can really be applied to any repo to
#   audit it.
.PHONY: search-env
search-env:
	find . -iname ".env" -print | xargs $(foreach e,$(SAVE_ENV_VARS),grep -vE '\s*export $(e)' |) awk -F '=' '{print $$2}' | sed '/^\s*$$/d' | grep -v '^$$(' | grep -v '^$${' | tr -d '"' | tr -d "'" | sort | uniq | while read line; do \
		if git rev-list --all | xargs git --no-pager grep $$line; then \
			exit -1; \
		fi \
	done

# Target added specifically for linux to disable system dns once the pi-hole
#   tries to bind to port 53. DNS is needed right up until that point, since
#   everything before then does require looking up/building containers.
.PHONY: disable-system-dns
disable-system-dns:
	@systemctl disable systemd-resolved.service
	@systemctl stop systemd-resolved

