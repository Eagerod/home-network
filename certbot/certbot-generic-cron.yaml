# The certbot update itself doesn't require any kind of special Kubernetes
#   access, but the process that copies the secrets from the file share to
#   Kubernetes' Secrets store does need to make API calls to Kubernetes.
# Create an account, and give it the ability to read and write Secrets in the
#   namespace this cron will copy data to.
apiVersion: v1
kind: ServiceAccount
metadata:
  name: certbot
  namespace: ${KUBERNETES_NAMESPACE}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: certbot-role
  namespace: ${KUBERNETES_NAMESPACE}
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "patch", "create"]  # Might actually be able to remove "list"?
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: certbot-manage-secrets
  namespace: ${KUBERNETES_NAMESPACE}
subjects:
  - kind: ServiceAccount
    name: certbot
roleRef:
  kind: Role
  name: certbot-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: certbot-update-script
  namespace: ${KUBERNETES_NAMESPACE}
data:
  update-secrets.sh: |
    #!/usr/bin/env sh
    #
    # Update secrets
    set -e

    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

    INTERNAL_WILDCARD_SECRET_NAME=internal-certificate-files
    INTERNAL_WILDCARD_COMBINED_SECRET_NAME=internal-certificate-file
    INTERNAL_WILDCARD_ARCHIVE=/etc/letsencrypt/archive/internal.aleemhaji.com-0001

    WILDCARD_SECRET_NAME=external-certificate-files
    WILDCARD_COMBINED_SECRET_NAME=external-certificate-file
    WILDCARD_ARCHIVE=/etc/letsencrypt/archive/aleemhaji.com-0001

    BARE_DOMAIN_SECRET_NAME=tls.aleemhaji.com
    BARE_DOMAIN_COMBINED_SECRET_NAME=tls-pem.aleemhaji.com
    BARE_DOMAIN_ARCHIVE=/etc/letsencrypt/archive/aleemhaji.com

    replace_certificates() {
      if [ -z $1 ] || [ -z $2 ]; then
        echo >&2 "Can't replace certs because cert name or path isn't present"
        exit 1
      fi

      cert_name="$1"
      cert_path="$2"

      rsa_keyfile="$(mktemp).rsa.key"

      latest_crt="$(find "$cert_path" -iname "fullchain*.pem" | sort -V | tail -1)"
      latest_key="$(find "$cert_path" -iname "privkey*.pem" | sort -V | tail -1)"

      openssl rsa -in "$latest_key" -out "$rsa_keyfile"

      echo "Updating ${KUBERNETES_NAMESPACE}/$cert_name..."
      kubectl create secret generic -n "${KUBERNETES_NAMESPACE}" "$cert_name" -o yaml \
        --dry-run=client \
        --save-config \
        --from-file="tls.key=$latest_key" \
        --from-file="tls.crt=$latest_crt" \
        --from-file="tls.rsa.key=$rsa_keyfile" |\
      kubectl apply -f -

      rm "$rsa_keyfile"
    }

    replace_combined_certificate() {
      if [ -z $1 ] || [ -z $2 ]; then
        echo >&2 "Can't replace certs because cert name or path isn't present"
        exit 1
      fi

      cert_name="$1"
      cert_path="$2"

      combined_file="$(mktemp).pem"

      latest_crt="$(find "$cert_path" -iname "fullchain*.pem" | sort -V | tail -1)"
      latest_key="$(find "$cert_path" -iname "privkey*.pem" | sort -V | tail -1)"

      cat "$latest_crt" "$latest_key" > "$combined_file"

      echo "Updating ${KUBERNETES_NAMESPACE}/$cert_name..."
      kubectl create secret generic -n "${KUBERNETES_NAMESPACE}" "$cert_name" -o yaml \
        --dry-run=client \
        --save-config \
        --from-file="keycert.pem=$combined_file" |\
      kubectl apply -f -

      rm "$combined_file"
    }

    replace_certificates "$INTERNAL_WILDCARD_SECRET_NAME" "$INTERNAL_WILDCARD_ARCHIVE"
    replace_combined_certificate "$INTERNAL_WILDCARD_COMBINED_SECRET_NAME" "$INTERNAL_WILDCARD_ARCHIVE"

    if ${INCLUDE_EXTERNAL_CERTS}; then
      replace_certificates "$WILDCARD_SECRET_NAME" "$WILDCARD_ARCHIVE"
      replace_combined_certificate "$WILDCARD_COMBINED_SECRET_NAME" "$WILDCARD_ARCHIVE"
    fi

    if ${INCLUDE_BARE_DOMAIN}; then
      replace_certificates "$BARE_DOMAIN_SECRET_NAME" "$BARE_DOMAIN_ARCHIVE"
      replace_combined_certificate "$BARE_DOMAIN_COMBINED_SECRET_NAME" "$BARE_DOMAIN_ARCHIVE"
    fi
---
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: certbot-copy-to-${KUBERNETES_NAMESPACE}
  namespace: ${KUBERNETES_NAMESPACE}
spec:
  schedule: "0 0 * * *"
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: certbot-copy-to-${KUBERNETES_NAMESPACE}
        spec:
          restartPolicy: OnFailure
          serviceAccountName: certbot
          imagePullSecrets:
            - name: registry.internal.aleemhaji.com
          containers:
            - name: certbot-copy-to-${KUBERNETES_NAMESPACE}
              image: registry.internal.aleemhaji.com/kubectl:1.21.0
              command:
                - sh
                - /scripts/update-secrets.sh
              env:
                - name: KUBERNETES_NAMESPACE
                  value: ${KUBERNETES_NAMESPACE}
              volumeMounts:
                - name: certbot-storage
                  mountPath: /etc/letsencrypt
                - name: certbot-scripts
                  mountPath: /scripts
          volumes:
            - name: certbot-storage
              nfs:
                server: 192.168.96.4
                path: /mnt/main/apps/certificates
            - name: certbot-scripts
              configMap:
                name: certbot-update-script
                defaultMode: 0755
